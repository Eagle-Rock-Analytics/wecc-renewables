""" "
## Module: Resource Drought Threshold Generation

This module calculates the long-term day-of-year mean for PV and wind energy production.
These means serve as the baseline thresholds for subsequent resource drought detection.
It processes either ERA5 reanalysis data or CMIP6 simulations centered around specific Global Warming Levels (GWL).
"""

import sys

import numpy as np
import pandas as pd
import xarray as xr

from postprocess.all_hourly_to_daily import mk_exclusions_mask


def rsrc_drought_threshold(
    domain: str, sim_id: str, module: str, gwl: str, var: str, tech: str
) -> None:
    """
    Calculate and save daily resource drought masks and percentages.

    Parameters
    ----------
    domain : str
        WRF domain identifier ('d03' or 'd02').
    sim_id : str
        Simulation name (e.g., 'ERA5', 'EC-Earth3').
    module : str
        Installation type (e.g., 'utility', 'onshore').
    gwl : str
        Global warming level (e.g., '0.8', '1.5', '2.0').
        We use 0.8 as our reference GWL.
    var : str
        Variable name ('gen' or 'cf').
    tech : str
        Technology type ('pv' or 'windpower').

    Returns
    -------
    None
    """

    member_dict = {
        "TaiESM1": "_r1i1p1f1",
        "MIROC6": "_r1i1p1f1",
        "EC-Earth3": "_r1i1p1f1",
        "MPI-ESM1-2-HR": "_r3i1p1f1",
        "ERA5": "",
    }
    member_id = member_dict[sim_id]
    sim = f"{sim_id}{member_id}"

    if sim_id == "ERA5":
        # no global warming level, needs to be treated differently
        scen = "reanalysis"
        my_years = [str(int(y)) for y in np.arange(1981, 2011)]
        zarr_path = f"s3://wfclimres/era/{tech}_{module}/{sim_id.lower()}/{scen}/day/{var}/{domain}/"
        ds = xr.open_zarr(zarr_path).sel(time=slice(my_years[0], my_years[-1]))
        # define output path
        out_path = f"s3://wfclimres/era/resource_drought/{tech}/{tech}_{module}/{sim_id.lower()}/{scen}/threshold/{domain}/"

        # extended description attribute
        ext_desc = "30-year (1981-2010) mean total power generated by installation."
        exp_id = scen

    else:
        # load in the global warming reference data
        gwl_df = pd.read_csv("../data/renewables_gwl_reference.csv")
        gwl_df = gwl_df.set_index("simulation")

        # define the global warming level window
        t = pd.to_datetime(gwl_df.loc[sim][gwl])
        y = int(t.date().year)
        y0 = y - 15
        y1 = y + 15

        # put gwl window into a list
        my_years = list(np.arange(y0, y1))

        # divide years by scenario: historical or ssp
        hist_years = [str(int(y)) for y in my_years if y < 2014]
        ssp_years = [str(int(y)) for y in my_years if y > 2014]

        # define output path
        out_path = f"s3://wfclimres/era/resource_drought/{tech}/{tech}_{module}/{sim_id.lower()}/plus{gwl.replace('.','')}c/threshold/{domain}/"

        if hist_years and ssp_years:
            scen0 = "historical"
            scen1 = "ssp370"
            zarr_path0 = f"s3://wfclimres/era/{tech}_{module}/{sim_id.lower()}/{scen0}/day/{var}/{domain}/"
            ds0 = xr.open_zarr(zarr_path0).sel(
                time=slice(hist_years[0], hist_years[-1])
            )
            zarr_path1 = f"s3://wfclimres/era/{tech}_{module}/{sim_id.lower()}/{scen1}/day/{var}/{domain}/"
            ds1 = xr.open_zarr(zarr_path1).sel(time=slice(ssp_years[0], ssp_years[-1]))
            ds = xr.concat([ds0, ds1], dim="time")
            exp_id = f"{scen0} + {scen1}"
        else:
            if hist_years:
                scen = "historical"
                gwl_years = hist_years
                exp_id = scen
            else:
                scen = "ssp370"
                gwl_years = ssp_years
                exp_id = scen
            zarr_path = f"s3://wfclimres/era/{tech}_{module}/{sim_id.lower()}/{scen}/day/{var}/{domain}/"
            ds = xr.open_zarr(zarr_path).sel(time=slice(gwl_years[0], gwl_years[-1]))

        # extended description attribute
        ext_desc = f"30-year mean total power generated by installation, centered at the 0.8C global warming threshold ({str(y)})."

    # make an exclusions mask to reintroduce the land use/cover nans.
    excl_mask = mk_exclusions_mask(ds)

    # ensure no leap days pop up during the dayofyear operation
    ds = ds.convert_calendar("noleap")
    ds["dayofyear"] = ds.time.dt.dayofyear
    ds["year"] = ds.time.dt.year
    ds = ds.assign_coords({"dayofyear": ds.time.dt.dayofyear, "year": ds.time.dt.year})
    # reshape time dimension
    ds = ds.drop_vars("time").set_index(time=["dayofyear", "year"]).unstack()
    # take day of year mean to use as subsequent reference values for resource droughts
    ds_mean = ds.copy(deep=True)
    ds_mean = ds[var].mean(dim="year", skipna=True).to_dataset().compute()

    # attach attributes
    ds_mean[var].attrs = ds[var].attrs
    ds_mean[var].attrs["frequency"] = "day of year mean"
    ds_mean[var].attrs["extended_description"] = ext_desc
    ds_mean.attrs = ds.attrs
    ds_mean.attrs["experiment_id"] = exp_id
    ds_mean["dayofyear"].attrs = {"long_name": "day of year"}
    ds_mean["x"].attrs = {"standard_name": "projection_x_coordinate", "units": "m"}
    ds_mean["y"].attrs = {"standard_name": "projection_y_coordinate", "units": "m"}

    # apply land use/cover mask
    ds_mean = xr.where(np.isnan(excl_mask), x=np.nan, y=ds_mean)

    # write to zarr
    ds_mean.to_zarr(out_path, mode="w")


if __name__ == "__main__":
    domain = str(sys.argv[1])
    sim_id = str(sys.argv[2])
    module = str(sys.argv[3])
    gwl = str(sys.argv[4])
    var = str(sys.argv[5])
    tech = str(sys.argv[6])

    rsrc_drought_threshold(domain, sim_id, module, gwl, var, tech)
