"""
Module for Wind Power Profile Re-gridding, Metadata Attachment, and Cataloging.

This module provides the primary function, 'catalog_windpower_profiles',
which is responsible for converting raw, ungridded wind power generation and
capacity factor profiles from temporary Zarr stores into a structured, gridded,
and fully-cataloged format suitable for public access and use.

The process involves:
1.  **Attribute Definition:** Defining extensive CF-compliant metadata for simulation details
    (WRF/CMIP6), scenario, installation characteristics (onshore/offshore), and variable
    attributes (capacity factor and generation).
2.  **Data Ingestion and Masking:** Reading ungridded Zarr time-series data and applying
    geographical and resource-suitability masks (e.g., excluding protected lands or
    high-slope areas, and applying a 'landmask' for offshore/onshore distinction).
3.  **Re-gridding:** Combining the ungridded data with a WRF coordinate template
    to re-grid the time series onto the high-resolution 'd02' or 'd03' WRF projection.
    This involves reindexing, unstacking the spatial dimensions (location to y, x),
    and assigning geographical coordinates (lon, lat).
4.  **Unit Conversion:** Applying necessary unit conversions and scaling factors (e.g.,
    capacity factor scale removal, converting generation from kW to MW).
5.  **Final Output:** Saving the resulting, fully attributed, gridded capacity factor ('cf')
    and generation ('gen') DataArrays as separate Zarr stores to a specified
    S3 bucket structure, organized by technology, simulation ID, scenario, and variable.

This module is designed to run via command-line arguments to process single, full-period
datasets based on a given domain, simulation, module, and scenario.
"""

import sys
from datetime import datetime

import numpy as np
import pandas as pd
import xarray as xr

from src.utils import ds_to_pretty_zarr, preprocess_ungridded_zarrs


def catalog_windpower_profiles(
    domain: str, sim_id: str, module: str, scen: str
) -> None:
    """
    Regrids hourly wind power capacity factor and generation profiles to the WRF grid
    and attaches metadata. The resulting zarrs are saved to a S3 bucket.

    Parameters
    ----------
    domain : str
        WRF domain identifier ('d03' or 'd02').
    sim_id : str
        WRF simulation name (e.g., 'ERA5', 'MIROC6').
    module : str
        Installation module ('utility', 'distributed', 'onshore', or 'offshore').
    scen : str
        Emissions scenario ('historical' or 'ssp370').

    Returns
    -------
    None
        The function saves the resulting dataset to a zarr store.
    """
    bucket = "wfclimres"
    ### --- Dictionaries for attributes dependent on parameters
    scen_attr_dict = {
        "reanalysis": "Historical Reconstruction",
        "historical": "Historical",
        "ssp370": "SSP 3-7.0",
    }
    scen_attr = scen_attr_dict[scen]
    scen_years_dict = {
        "reanalysis": list(np.arange(1981, 2014)),
        "historical": list(np.arange(1981, 2014)),
        "ssp370": list(np.arange(2015, 2099)),
    }
    sim_years = scen_years_dict[scen]
    domain_res_dict = {"d03": "3 km", "d02": "9 km"}
    nom_res = domain_res_dict[domain]
    turbine_count_dict = {"d03": "9", "d02": "81"}
    turbine_count = turbine_count_dict[domain]
    install_cap_dict = {"d03": "27000 MW", "d02": "243000 MW"}
    install_cap = install_cap_dict[domain]

    # ---- Define a whole bunch of file attributes
    member_dict = {
        "TaiESM1": "_r1i1p1f1",
        "MIROC6": "_r1i1p1f1",
        "EC-Earth3": "_r1i1p1f1",
        "MPI-ESM1-2-HR": "_r3i1p1f1",
        "ERA5": "",
    }
    member_id = member_dict[sim_id]
    sim_attr_dict = {
        "experiment_id": scen_attr,
        "source_id": f"WRF_{sim_id}{member_id}",
    }
    cf_metadata = {
        "long_name": "capacity factor",
        "units": "1",
        "data_type": "Gridded",
        "frequency": "1hr",
        "grid_mapping": "Lambert_Conformal",
        "extended_description": (
            "Ratio of power generated to" + " turbine nameplate capacity."
        ),
    }
    gen_metadata = {
        "long_name": "generated power",
        "units": "MW",
        "data_type": "Gridded",
        "frequency": "1hr",
        "grid_mapping": "Lambert_Conformal",
        "extended_description": ("Total power generated by installation."),
    }
    var_attr_dict = {"gen": gen_metadata, "cf": cf_metadata}
    onshore_attrs = {
        "turbine_installation_type": "Onshore",
        "turbine_hub_height": "100 meters",
        "turbine_rotor_diameter": "127.5 meters",
        "turbine_nameplate_capacity": "3 MW",
        "installation_turbine_count": turbine_count,
        "installation_total_capacity": install_cap,
    }
    offshore_attrs = {
        "turbine_installation_type": "Offshore",
        "turbine_hub_height": "120 meters",
        "turbine_rotor_diameter": "180 meters",
        "turbine_nameplate_capacity": "8 MW",
        "installation_turbine_count": "9",
        "installation_total_capacity": "72000 MW",
    }
    mod_md_dict = {"offshore": offshore_attrs, "onshore": onshore_attrs}
    ds_metadata = {
        "Conventions": "CF-1.8",
        "nominal_resolution": nom_res,
        "institution": "Eagle Rock Analytics",
        "institution_email": "info@eaglerockanalytics.com",
        "power_generation_model": (
            "Renewable Energy Potential (reV) v0.9.4"
            + " Zenodo. https://doi.org/10.5281/zenodo.12548947"
        ),
        "power_generation_model_citation": (
            "Grant Buster, Michael Rossol, Paul Pinchuk,"
            + " Brandon N Benton, Robert Spencer,"
            + " Mike Bannister, & Travis Williams. (2023)."
            + " NREL/reV: reV 0.8.0 (v0.8.0).)"
        ),
        "system_advisory_model": "Windpower",
    }
    ds_metadata.update(mod_md_dict[module])
    ds_metadata.update(sim_attr_dict)
    # ---- DONE attribute definitions ----

    # ---- read in some reference files we need ----
    zarr_template = (
        f"s3://wfclimres/era/resource_data/{domain}/static_files/coord_ds_{domain}.zarr"
    )
    template_ds = xr.open_dataset(
        zarr_template,
        engine="zarr",
        consolidated=True,
    )
    template_ds = template_ds.squeeze().drop_vars("time")
    lons = template_ds["lon"]
    lats = template_ds["lat"]
    template_ds = template_ds.stack(location=["y", "x"])

    meta = pd.read_csv(f"../../rev_configs/{domain}_all_points.csv")
    mask_gen = meta.loc[
        (meta["wind_slope_over_20p"] != 1)
        & (meta["wind_land_cover_urban_medium_high"] != 1)
        & (meta["fed_and_state_protected"] != 1)
    ]
    if module == "offshore":
        mask = mask_gen.loc[(mask_gen["landmask"] != 1)]
    else:
        mask = mask_gen.loc[(mask_gen["landmask"] == 1)]

    filepath_zarr = f"s3://{bucket}/era/tmp/ungridded/Windpower/{domain}/{module}/{sim_id}/wind_{module}_{sim_id}_"
    filepaths_zarr = [filepath_zarr + f"{y}.zarr/" for y in sim_years]
    wind_ds = xr.open_mfdataset(
        filepaths_zarr,
        engine="zarr",
        consolidated=True,
        preprocess=preprocess_ungridded_zarrs,
        combine="nested",
        concat_dim="time",
    )
    wind_ds["time"] = [
        datetime.strptime(s[:-6].decode(), "%Y-%m-%d %H:%M:%S")
        for s in wind_ds.time_index.values
    ]
    wind_ds = wind_ds.assign_coords({"gid": mask.index})
    wind_ds = wind_ds.drop(["time_index"])

    ix_ds = meta.to_xarray()  # need indices
    ix_ds = ix_ds.assign_coords({"time": wind_ds["time"]})
    ix_ds = ix_ds.rename({"index": "gid"})
    # do the reindexing
    wind_ds = wind_ds.reindex_like(ix_ds)
    # change index name and assign coords
    wind_ds = wind_ds.rename_dims({"gid": "location"}).drop_indexes("gid")
    wind_ds = wind_ds.assign_coords({"location": template_ds.indexes["location"]})
    wind_ds = wind_ds.drop_vars("gid")
    wind_ds = wind_ds.unstack()
    wind_ds = wind_ds.assign_coords({"lon": lons, "lat": lats})
    out_ds = wind_ds[["cf_profile", "gen_profile"]]  # subset core variables
    out_ds["cf_profile"] = out_ds["cf_profile"] * 1e-6  # remove scale factor
    out_ds["gen_profile"] = out_ds["gen_profile"] * 1e-3  # kW -> MW
    out_ds = out_ds.rename({"cf_profile": "cf", "gen_profile": "gen"})
    out_ds = out_ds.drop(["member_id", "lakemask"], errors="ignore")
    out_ds.x.attrs = {"standard_name": "projection_x_coordinate", "units": "m"}
    out_ds.y.attrs = {"standard_name": "projection_y_coordinate", "units": "m"}
    out_ds = out_ds.chunk(chunks={"time": 8760, "y": 87, "x": 42})
    # ship off the two vars to their new homes
    for var in ["cf", "gen"]:
        out_da = out_ds[var].to_dataset()
        out_da[var].attrs = var_attr_dict[var]
        out_da.attrs = ds_metadata
        outpath = f"era/windpower_{module}/{sim_id.lower()}/{scen}/1hr/{var}/"
        outname = f"{domain}"
        print(outpath + outname)
        ds_to_pretty_zarr(out_da, outpath, outname, bucket=bucket)


if __name__ == "__main__":
    domain = str(sys.argv[1])
    sim_id = str(sys.argv[2])
    module = str(sys.argv[3])
    scen = str(sys.argv[4])
    catalog_windpower_profiles(domain, sim_id, module, scen)
